{
  
    
        "post0": {
            "title": "A primer on unsupervised domain adaptation",
            "content": ". toc: true layout: post description: An introduction to popular practices in UDA. categories: [markdown] title: A primer on Unsupervised Domain Adaptation coments: true use_math: true . A primer on Unsupervised Domain Adaptation . AI has ushered us into a new era of a technological revolution. From detecting brain tumours to autonomous navigation, AI has founded its way into our everyday life in a very short amount of time, so much so that there is a consensus that AI will soon take over the world. However, that possibility is far into the future. At the heart of such tremendous advancement in AI are the Deep Learning (DL) algorithms. DL is a branch of machine learning algorithms that can approximate any function over a finite set of iterations. However, there are two limitations to this wonder algorithm. Firstly, they need a lot of hand-annotated training examples and secondly, they do not generalise well to examples outside of the training data. Although the first problem can be solved to a certain extent by synthetically generating training pairs, it is the issue with models not generalizing to out of distribution data that is more troublesome. For example, an autonomous navigation DL model trained on US road images will not work in the Indian setting. For a model to work on Indian roads we will need to collect and annotate huge amounts of data from Indian roads and train a model from scratch which is both expensive and time-consuming. . Introduction . The main reason behind a DL model’s poor generalisability is the difference in the target and source data distribution which is also known as domain shift. A workaround will be to fine-tune a pre-trained model on a target task by annotating only a small amount of the target data. However, the amount of annotated data required for finetuning depends on the task at hand. For example, sequences based tasks like Machine Translation or Speech Transcription require a lot of effort and labelling even a small portion of the dataset can take a significant amount of time and effort. Another way would be to train the model in an unsupervised manner such that it learns to focus on features that are domain invariant. Such methods fall under the umbrella of unsupervised domain adaptation (UDA) and it is something that we will discuss in much more detail in this blog post. . Formally, Domain Adaptation can be defined as a set of methods or practices that enable the model trained on a “source” data to perform well on a “target” data distribution. Finetuning can also be considered as a domain adaptation technique. However, in this blog post, we will look only at those domain adaptation techniques that do not require any labels in the target domain i.e. unsupervised domain adaptation. . In this blog post, we look at several unsupervised domain adaptation techniques. This post can be thought of as a mini-literature survey meant to initiate the readers on the topic of UDA. Although there can be various approaches towards solving UDA, I have focused on two of the most common techniques: (a) Adversarial (b) Self-Supervised. For both approaches, I have picked some of the most relevant papers and tried to explain them as concisely as possible. . . Fig.1. shows the t-SNE visualization of CNN features for (a) before and (b) after adaptation is performed on CNN features. The Bluepoints correspond to source domain examples and the red data points refer to target examples. (Image source: Ganin et al., 2015) . Adversarial Domain adaptation . UDA aims to align the source and target features such that they are indistinguishable from the classifier. There are several possible ways one can achieve this. Sun and Saenko minimise the first and second-order moments for the source and target data. Another way is via maximizing the mean discrepancy of target and source feature distribution proposed by Long and Wang. However, one of the most common and intuitive ways to align source and target data distribution is via adversarial learning. . Gradient Reversal . Ganin et al., 2016 was one of the earliest works to explore domain adaptation via adversarial learning. The underlying principle is very simple. They formulate the problem as a classification task where the classifier should be able to perform well not just on source features but also on the target features. They define a feed-forward architecture that should be able to predict not just the label of the input but also its domain label i.e. whether it belongs to the source or target category. . They decompose such a mapping into three parts (refer Fig.2.): . $G_f(a feature extarctor)$ with parameters $ theta_f$ which maps the input $x$ into a $D$-dimensional feature vector ($f$) which is then mapped by | $G_y(label predictor)$ with parameters $ theta_y$ which maps the feature vector $f$ to a label space $y$. | $G_d$ with parameters $ theta_d$, which maps the same feature vector $f$ to the domain label $d$. | Like any feedforward network, they optimise the feature extractor and label predictor to minimize the label prediction loss on source labels. At the same time, they want both the source and target feature distributions to be close to each other so that accuracy on the target domain remains same as the accuarcy on the source domain. To learn domain invariant features, during training time, the authors pose the optimization problem such that $ theta_f$ seeks to maximize the loss of the domain classifier, while $ theta_d$ of the domain classifier tries to minimize the loss of the domain classifier. begin{equation} begin{array}{l} E( theta_f, theta_y, theta_d)= sum_{l=1 atop d_{i}=0}^{N} L_{y} left( theta_{f}, theta_{y} right)- lambda sum_{i=1}^{N} L_{d} left( theta_{f}, theta_{d}) right. end{array} end{equation} . Equation 1 represents the overall loss function. Here $L_y$ is the classifier loss, $L_d$ is the domain classifier loss. Optimal parameters will result in a saddle point. begin{equation} ( theta_f, theta_y) = arg min E( theta_f, theta_y, theta_d) end{equation} . begin{equation} theta_d = arg max E( theta_f, theta_y, theta_d) end{equation} . The above optimization problem can be thought of as a min-max game between the feature extractor and the domain classifier. The $ theta_d$ of the domain classifier tries to minimize the domain classification loss while $ theta_f$ of the feature extractor tries to fool the domain discriminator, thereby maximizing the domain classification loss. On the other hand, since we want to learn discriminative features for both source and target samples, $ theta_f$ and $ theta_y$ seek to minimize the label prediction loss. . . Fig.2. The architecture proposed by Ganin et al. 2015. The figure highlights the feature extractor, the label predictor and the domain classifier. Gradient reversal is achieved by multiplying the domain classifier gradient w.r.t with a negative constant. Gradient reversal ensures that the source and target feature distributions lie close to each other. (Image source Ganin et al. 2015) . Intuition behind the gradient reversal layer . Without the gradient reversal layer, the network will behave like a traditional feed-forward network. The network will be good at predicting the class label as well as the domain labels. However, we do not want that. We want the network to predict the class labels correctly but only on features that are domain invariant. To obtain domain invariant features, the authors propose to reverse the gradients coming from the domain classifier and going into the feature extractor. Gradient reversal is achieved by multiplying $ frac{ partial L_d}{ partial theta_f}$ with a negative constant $ lambda$. Multiplying $ frac{ partial L_d}{ partial theta_f}$ and not $ frac{ partial L_d}{ partial theta_d}$ with a negative constant enforces a min-max game between the feature extarctor and the domain discriminator, where the feature extractor tries to learn features which can fool the disciminator, thus maximizing the domain prediction loss. . Self-supervised Domain Adaptation . Although adversarial domain adaptation works quite well, they pose the training objective as a min-max training problem which is known to be quite difficult to solve. The training often does not converge and if it does, it converges to a bad local maximum. One also need to balance the two sets of parameters (for generator and discriminator) so that one does not dominate the other. Self-supervised domain-adaptation avoids the adversarial game altogether and seeks to align the source and target features by training a model on an auxiliary task in both domains. . Rotation, Flip and Patch prediction . Although, one can choose a variety of auxiliary tasks such as Image colourization or image in-painting, Sun e al., 2019 verified empirically that such pixel prediction/reconstruction task is ill-suited for domain adaptation as they induce domain separation. They showed that classification tasks which predict labels based on label structure such as Rotation prediction, Flip Prediction and Patch location prediction are more suited for domain adaptation. . . Fig. 3. shows how the source and target features are aligned on a shared feature space (a) before and (b) after training the model on a single auxiliary task which subsequently leads to alignment of domains along a particular direction. (c) highlights when we train the model on multiple self-supervised tasks which further aligns the domains along with multiple directions. (Image source Sun et al., 2019) . They proposed a method where in addition to the supervised classification loss on source data points $L_0$, they also had a set of $K$ self-supervised tasks, each with its separate loss function $L_k$ where $k=1 dots,K$. All the task-specific heads $h_k$ for $k=0 dots K$, share a common feature extractor $ phi$ as shown in Fig.3. where $ phi$ is a convolutional neural network and each $h_k$ is a linear layer. . . Fig. 3. shows the architecture proposed by Sun et al., 2019. The network is trained jointly on the source and target examples. Each head corresponds to a separate task either supervised or self-supervised and has its separate loss function associated with it. All the heads share a common feature extractor, which learns to align feature distributions. (Image source Sun et al., 2019) . So if $S = {(x_i, y_i), i=1 dots m}$ is the labeled source data and $T = {(x_i), i = 1 dots n}$ is the unlabelled target data then the overall loss function can be written as: begin{equation} L = sum L_0(S; phi,h_0) + sum_{k=1}^{K}L_k(S,T; phi,h_k) end{equation} Here, we see that the term $L_k$ unlike the term $L_0$ takes both the source and target examples which is crucial for inducing feature alignment. In their paper, the authors set $K=3$, where the auxiliary tasks are the ones mentioned above. . Jigsaw puzzles . Carlucci et al., 2019 via a similar approach showed that domain adaptation could be achieved by when a model is trained to solve jigsaw puzzles i.e. recovering an image from its shuffled parts for both source and target examples. The authors argue that solving the jigsaw puzzle as a side objective to the real classification task act not only as a regularisation measure but also aids in feature adaptation. The overall loss function is similar to equation 4 with being equal to . Open Set Domain Adaptation . The examples that we have seen till now belong to the closed set domain adaptation where there is a complete overlap between the source and target labels. However, in real-world applications, it will be difficult to say a priori whether our task will have the same set of labels as our source task. In many practical scenarios, our target task may have labels that are unseen in the source task. In such cases, the closed-set distribution matching algorithms will try to align the source and target domains irrespective of the fact whether the source and target domains share the same label space or not. This will cause the data samples with the “unknown” classes in the target domain to also become aligned with the “known” classes in the source domain which will deteriorate the performance of the model and lead to negative transfer (a phenomenon where an adapted model performs poorly as compared to a model which was trained exclusively on source data). Thus it becomes important to identify a boundary between the known and unknown samples and apply adaptation only on those samples which have the same classes as the source. . . Fig.4. (a) Closed set domain adaptation with distribution matching algorithm. (b) Open set domain adaptation with distribution matching algorithm. The unknown classes in the target domain are aligned with the known classes of the source domain. (Image source Saito et al., 2018) . Adversarial Open Set Domain adaptation . Open set domain adaptation was proposed Busto et al., 2017 where the target and source domain categories do not overlap completely. The main idea behind their solution was to be able to draw a decision boundary that can differentiate between the target samples belonging to either the “known” or “unknown” class and classify correctly only the “known” class target samples. To do so, they add unknown source samples to the known source samples to learn a mapping that can classify the target samples to either one of the “known” classes or the “unknown” class. Although the algorithms do a decent job, collecting unknown source samples can be a challenging task since we must collect a diverse set of unknown samples to define what is unknown. . Gradient Reversal via Back-propagation . Saito et al., 2018 proposed a method for open set DA which involved no “unknown” source samples. Their method is similar to the one proposed by Ganin et al., 2016 with a few tweaks to also consider the unknown target samples. Fig. 5. shows the architecture used in their paper. . . Fig. 5. Network architecture proposed by Saito et al., 2018. The above architecture consists of a feature generator (G) and a classifier (C) which can classify a data point into K+1 (K known classes and an unknown class). The proposed method makes use of a Gradient Reversal Layer similar to the one proposed by Ganin et al., 2016. (Image source Saito et al., 2018) . The main objective as mentioned earlier is to correctly classify the “known” target samples and differentiate the “unknown” target from class samples from the “known”. To achieve this, one needs to create a decision boundary that can correctly separate the “unknown from the known samples. However, since there is no label information for the target samples, the authors propose to come up with a pseudo decision boundary by training the classifier to classify all the target samples as belonging to the “unknown” class. The role of the feature generator would then be to fool the classifier into believing that the target samples comes from the source domain.* . However, there is a small catch in this. In the traditional sense, if we were to train a classifier to classify the target sample as unknown, then it would be as good as saying that we want the output probability of the target sample to be . In such a case, for the generator to deceive the classifier, it should align the target samples completely with the source samples. The generator will try to decrease the probability for the unknown class which will ultimately lead to negative transfer. . To combat the above situation, the authors propose that the classifier should output a probability instead of 1, where . The generator can choose to either increase or decrease the value of the output probability of an unknown sample and thereby maximize the classifier error. Now, this has two implications. If the generator chooses to decrease output probability lower than , then it essentially means that the target sample is aligned with the source class. Similarly, if output probability is increase to a value greater than , then it means that the sample must be rejected. . Equation 5 refers to the cross-entropy loss used to train the model to identify the source data into one of the known classes. begin{equation} L_s(x_s, y_s) = -log(p(y = y_s|x_s)) end{equation} For training a classifier to learn a decision boundry seperating the known and unknown classes, the authors propose binary cross-entropy loss. begin{equation} L_{adv}(x_t) = -tlog(p(y = K + 1|x_t)) - (1 - t)log(1 - p(y = K + 1|x_t)) end{equation} Where $t$ is set as $0.5$. . The overall training objective becomes begin{equation} L_C = min(L_s(x_s, y_s) + L_{adv}(x_t, y_t) end{equation} . begin{equation} L_G = min(L_s(x_s, y_s) - L_{adv}(x_t, y_t) end{equation} . Intuition . But wait a minute. How does the feature extractor choose? I mean it is possible that the feature extractor mistakenly assumes that a particular “unknown” target sample belonging to the “known” class. In such a case, the feature extractor can decide to manipulate its feature vector such that the classifier outputs a probability score of less than . In such a case the unknown class target sample becomes aligned to the known source sample which will then lead to negative transfer. . However, the authors claim that the feature extractor can recognize the distance between each target sample and the boundary between the known and the unknown class. Thus, for the target samples which are similar to the source samples, the extractor tries to align them to the known source samples and for the different ones it tries to separate them from the known class. . Self-supervised Open set Domain Adaptation . Now that we have looked at adversarial open set domain adaptation, it only makes sense to look at its self-supervised counterpart. Saito et al., 2020 took a leaf out of a prototype-based few-shot learning paradigm and propose a technique called “Neighbourhood Clustering (NC)”. In NC each target sample is either aligned to the “known” class prototype in the source or its neighbour in the target. NC encourages the target samples to be well clustered. However, we also want to know which target samples should be aligned with the source and which target samples should be rejected as “unknown”. It is always possible for a target sample belonging to a “known” class to be clustered around another target sample of the same class instead of the source prototype. Thus, in addition to NC, the authors also propose an “Entropy Separation loss” (ES) to draw a decision boundary to separate the “known” and the “unknown” class samples. . Neighbourhood Clustering and Entropy Separation . In NC, the authors try to minimize the entropy of a target samples’ similarity distribution to other target samples and source prototype. By doing so, the authors claim that the target sample will either move to a nearby target sample or a source prototype. To do so, the authors first calculate the similarity of each target point to all the other target samples and the class prototypes for each mini-batch of target features. In the paper, the class prototypes are the weight vectors of the last fully connected layer of the network trained to classify the source data points. . Thus, if $N_t$ denotes the number of target examples and K denotes the number of classes, then $V in R^{N_t times d}$ denotes the memory bank containing all the target features and $F in R^{(N_t + K) times d}$ denotes all the feature vectors in the memory bank and the prototype vectors where $d$ is the dimension of last linear layer. begin{equation} V = [V_1, V_2 dots V_{N_t}] end{equation} . begin{equation} F = [V_1, V_2, dots V_{N_t}, w_1, w2 dots w_k] end{equation} . Since the authors calculate the similarity of feature vectors at a mini-batch level, they employ $V$ to store the features which are not present in the mini-batch. Let $f_i$ denote the features in the mini-batch and $F_j$ denote the $j$-th term in $F$, then the similarity matrix for all the features in the mini-batch can be obtained by: begin{equation} p_{i,j} = frac{exp(F_j^T f_i/ tau)}{Z_i} end{equation} . begin{equation} Z_i = sum_{j=1, j ne i}^{N_t + K} exp(F_{j}^T f_i/ tau) end{equation} . where, $ tau$ is the temperature parameter, which controls the number of neighbours for each sample. . The entropy is then calculated by begin{equation} L_{nc} = - frac{1}{B_t} sum_{i in B_t} sum_{j=1,j ne i}^{N_t + K}p_{i,j}log(p_{i,j}) end{equation} Here, $B_t$ refers to all target sample indices in the mini-batch. . The authors make use of the entropy of the classifier’s output to separate the known from the unknown target samples. The intuition behind this is that “unknown” target samples are likely to have higher entropy since they do not share any common features with the “known” source classes. . The authors define a threshold boundry $ rho$ and try to maximize the distance between the entropy and the threshold which is defined as $|H(p) - rho|$. They assume $ rho = frac{log(K)}{2}$, $K$ being the number of classes. The value is chosen empirically. The authors further claim that the value of threshold is ambiguous and can change due to domain shift. Therefore, they introduce a confidence parameter $m$ such that the final form becomes. begin{equation} L_{es} = frac{1}{|B_t|} sum_{i in B_t}L_{es}(p_i) end{equation} . begin{equation} L_{es}(p_i) = begin{cases} -|H(p_i) - rho| &amp; |H(p_i) - rho|&gt; m 0 &amp; otherwise end{cases} end{equation} . confidence parameter $m$ allows seperation loss only for the confident samples. Thus when $ | H(p) - rho | $ is sufficiently large, the network is cofident about a target sample belonging to “known” or “unknown” class. | . The final loss function then becomes begin{equation} L = L_{cls} + lambda(L_{nc} + L_{es}) end{equation} where $L_{cls}$ is the classifier loss on source samples and $ lambda$ is a weight parameter. . Category-Agnostic Clusters for Open-Set Domain Adaptation . Till now in open domain set domain adaptation we learn a binary classifier to classify a target sample into one of the many “known” source classes or categorize them as belonging to an “unknown” class. However, in doing so we unintentionally group the target samples into just one class, leaving their inherent data distribution unexploited. To alleviate this problem Pan et al., 2020 proposed a method that performs clustering over all unlabelled target samples to extract to preserve the discriminative features of target samples belonging to both the known and unknown classes and at the same time being domain invariant for known class target samples. They propose a Self-Ensembling (SE) based method with category agnostic clustering (CC) to achieve this (Fig. 6.). . . Fig. 6. Provides an overview of the SE-CC method. Image source Pan et al., 2020 . Self-Ensembling . SE is similar to consistency based training where a two perturbed version of the same data point is passed to the network and the network should predict similar classification distribution over all the classes for both versions. The proposed architecture consists of a Student and a Teacher branch. Given two perturbed versions $x_t^S$ and $x_t^T$ from the same target sample $x_t$, the SE loss penalizes the difference between classification predictions of student and teacher branch. begin{equation} L_{se} = ||P_{cls}^S(x_t^S) - P_{cls}^T(x_t^T)||_2^2 end{equation} During training, the student model is trained using gradient descent while the weights of the teacher model are adjusted using the Exponential moving average of student weights. The authors also make use of conditional entropy to train the student branch. Thus, overall loss becomes begin{equation} L_{SEC} = sum L_{CLS}(x_s, y_s) + sum_{x in T} (L_{SE}(x_t) + L_{CDE}(x_t)) end{equation} Category Agnostic Clustering . To not group all the unknown target samples in just one class, the authors introduce a clustering branch in the student model to align its estimated cluster assignment distribution with the inherent cluster distribution among the category-agnostic clusters. . The authors perform K-means clustering over the target features. Although, the clusters so obtained is category agnostic, they reveal the underlying data distribution in the target domain i.e. its inherent cluster distribution. Next, the authors compute softmax over the cosine similarity between target samples and each cluster centroid. begin{equation} hat{P}_{clu}(x_t) = frac{e^{ rho . cos(x_t, mu_k)}}{ sum_{k}e^{ rho . cos(x_t, mu_k)}}, mu_k= frac{1}{|C_k|} sum_{x_t in C_k} x_t end{equation} . Clustering Branch . The clustering branch is designed to predict the distribution over all category category-agnostic clusters. Depending on the input feature $x_t^S$ the clustering branch assigns it to one of the $K$ clusters and that is how we obtain the target feature’s cluster assignment distribution $P^k_{clu}(x_t^S) in R$ via a modified softmax layer. begin{equation} P_{clu}^k(x_t^S) = frac{e^{ rho . cos(x_t^S, W_k)}}{ sum_{k}e^{ rho . cos{x_t^S, W_k}}} end{equation} Here, $P_{clu}^k(x_t^S)$ represents the probability of assigning $x_t^S$ into $k$-th cluster. $W_k$ is the $k$-th row of parameter matrix $W in R^{K times M}$ in the modified softmax layer, represents the cluster assignment parameter matrix for the $k$-th cluster. . To measure the similarity between the estimated cluster assignment from the clustering branch and the inherent cluster distribution obtained using $K$-means clustering, the authors have used the KL-divergence loss. begin{equation} L_{KL} = sum_{x_t in T} KL( hat{P}_{clu}(x_t)||P_{clu}(x_t^S)) end{equation} The authors claim that by enforcing KL divergence, the learnt representations for target samples belonging to the known samples become aligned to the source and all the target samples retain their inherent discriminitiveness. . In addition to the above practices, the authors also make use of Mutual Information both at local and global level to further enhance the learnt representations. . Conclusion . In the above blog post, we saw several approaches towards mitigating the domain shift between the target and source dataset in an unsupervised manner. We also explored the two types of domain adaptation namely, closed-set and open-set and saw the disadvantages of applying closed-set DA strategies for open-set DA tasks. We also discussed an improvement in the traditional open-set DA setup where minimizing the divergence between the inherent cluster distribution and the predicted cluster distribution can not only help in aligning the source and target features but also help the target features retain their inherent discriminative ness. In the next post, we will domain adaptation approaches when a few of the target samples are labelled. Such techniques fall under the purview of Few-shot domain adaptation and will hopefully prove to be an interesting read. .",
            "url": "https://deepayan137.github.io/blog/2021/03/28/A-primer-on-Unsupervised-Domain-Adaptation.html",
            "relUrl": "/2021/03/28/A-primer-on-Unsupervised-Domain-Adaptation.html",
            "date": " • Mar 28, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Building a custom OCR using pytorch",
            "content": ". So in this tutorial, I will give you a basic code walkthrough for building a simple OCR. OCR as might know stands for optical character recognition or in layman terms it means text recognition. Text recognition is one of the classic problems in computer vision and is still relevant today. One of the most important applications of text recognition is the digitization of old manuscripts. Physical copies of books and manuscripts are prone to degradations. With time, the printed characters start to fade. One simple way to preserve such documents is to make a digital copy of it and store it in the cloud or local hard drive which would ensure their continuance. Scanning the document or taking picture seems like a viable alternative, however if you want to perform search and retrieval or some other edit actions on the document then OCR is the way to go.Similarly, text recognition can also be used for licence plate recognition and can also be used in forensics in terms of handwriting recognition. . Okay, now that I have given you enough motivation as to why OCR is important, let me show you how you can build one. You can find the ipython notebook as well as the other dependencies in this repo. So, in case you want to run the code alongside just do a quick git clone https://github.com/Deepayan137/Adapting-OCR . This blog assumes that you are fairly familiar with Python and Pytorch deep learning framework. If not then I will recommend you going through the Pytorch 60 minutes blitz page. It provides a nice primer on the Pytorch framework. For more details consider going through Fastai course. . So first things first, I’ll start with listing down some of the essential packages that you would need to build your first OCR. As mentioned we will be working with PyTorch 1.5 as it is one of the most efficient deep learning libraries present. The other packages are as follows: . Matplotlib | Tqdm | textdistance | lmdb | . You can install them either via a pip or conda. I will also be providing a requirements.txt which you can find in my Github repo. Do a simple pip install -r requirements and you are good to go. . Setting up the Data . We will start our project by importing the necessary libraries. But before that we need data. Now, you are free to use any data you might like (as long as it is related to documents) and for that, you might need to build your own data loader. However, in the interest of keeping things simple, we will be using a neat little package called trdg, which is a synthetic image generator for OCR. You can find all the relevant information regarding this package on its github repository. You can generate printed as well as hand-written text images and infuse them with different kinds of noise and degradation. In this project, I have used trdg to generate printed word images of a single font. You can use any font you like. Just download a .ttf file for your font and while generating the word images be sure to specify the -ft parameter as your font file. . You can generate the word images for training using the following commands: . trdg -i words.txt -c 20000 --output_dir data/train -ft your/fontfile . Here, -c refers to the number of word images you want to generate. words.txt file contains our input word vocabulary while --output_dir and -ft refer to the output and font file respectively. You can similarly generate the test word images for evaluating the performance of your OCR. However, ensure that words for training and testing are mutually exclusive to each other. . Now that we have generated the word images, let us display a few images using matlplotlib %# TODO diplay images from folder . Lets start importing the libraries that we would need to build our OCR . import os import sys import pdb import six import random import lmdb from PIL import Image import numpy as np import math from collections import OrderedDict from itertools import chain import logging import torch import torch.nn as nn import torch.nn.functional as F from torch.utils.data import Dataset from torch.utils.data import sampler import torchvision.transforms as transforms from torch.optim.lr_scheduler import CosineAnnealingLR, StepLR from torch.nn.utils.clip_grad import clip_grad_norm_ from torch.utils.data import random_split from src.utils.utils import AverageMeter, Eval, OCRLabelConverter from src.utils.utils import EarlyStopping, gmkdir from src.optim.optimizer import STLR from src.utils.utils import gaussian from tqdm import * . Next, let us create our data pipe-line. We do this by inheriting the PyTorch Dataset class. The Dataset class has few methods that we need to adhere to like the __len__ and __getitem__ method. The __len__ method returns the number of items in our dataset while __getitem_ returns the data item for the index passed. You can find more information on PyTorch Dataset class on PyTorch’s official documentation page. . You will observe that we first convert each image into grayscale and convert it into a tensor. This is followed by normalizing the images so that our input data lies within a range of [-1, 1]. We pass all such transformations into a list and later call the transforms to .Compose function provided by PyTorch. The transforms.Compose function applies each transformation in a pre-defined order. . class SynthDataset(Dataset): def __init__(self, opt): super(SynthDataset, self).__init__() self.path = os.path.join(opt[&#39;path&#39;], opt[&#39;imgdir&#39;]) self.images = os.listdir(self.path) self.nSamples = len(self.images) f = lambda x: os.path.join(self.path, x) self.imagepaths = list(map(f, self.images)) transform_list = [transforms.Grayscale(1), transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,))] self.transform = transforms.Compose(transform_list) self.collate_fn = SynthCollator() def __len__(self): return self.nSamples def __getitem__(self, index): assert index &lt;= len(self), &#39;index range error&#39; imagepath = self.imagepaths[index] imagefile = os.path.basename(imagepath) img = Image.open(imagepath) if self.transform is not None: img = self.transform(img) item = {&#39;img&#39;: img, &#39;idx&#39;:index} item[&#39;label&#39;] = imagefile.split(&#39;_&#39;)[0] return item . Next, since we are going to train our model using the mini-batch gradient descent, it is essential that each image in the batch is of the same shape and size. For this, we have defined the SynthCollator class which initially finds the image with maximum width in the batch and then proceeds to pad the remaining images to have the same width. You migh wonder as to why we are not concerned with the height, it is because while generating the images using the trdg package, I had fixed the height to 32 pixels. . class SynthCollator(object): def __call__(self, batch): width = [item[&#39;img&#39;].shape[2] for item in batch] indexes = [item[&#39;idx&#39;] for item in batch] imgs = torch.ones([len(batch), batch[0][&#39;img&#39;].shape[0], batch[0][&#39;img&#39;].shape[1], max(width)], dtype=torch.float32) for idx, item in enumerate(batch): try: imgs[idx, :, :, 0:item[&#39;img&#39;].shape[2]] = item[&#39;img&#39;] except: print(imgs.shape) item = {&#39;img&#39;: imgs, &#39;idx&#39;:indexes} if &#39;label&#39; in batch[0].keys(): labels = [item[&#39;label&#39;] for item in batch] item[&#39;label&#39;] = labels return item . Defining our Model . Now we proceed to define our model. We use the CNN-LSTM based architecture which was proposed by Shi et.al. in their excellent paper An End-to-End Trainable Neural Network for Image-based Sequence Recognition and Its Application to Scene Text Recognition. The authors used it for scene-text recognition and showed via extensive experimentation that they were able to achieve significant gains in accuracy compared to all other existing methods at that time. . . The figure above shows the architecture used in the paper. The authors used a 7 layered Convolution network with BatchNorm and ReLU. This was followed by a stacked RNN network consisting of two Bidirectional LSTM layers. The convolution layers acted as a feature extractor while the LSTMs layers act as sequence classifiers. The LSTM layers output the probability associated with each output class at each time step Further details can be found in their paper and I strongly suggest you go through it for a better understanding. . The below code snippet is taken from this github repository which provides a Pytorch implementation of their code. . class BidirectionalLSTM(nn.Module): def __init__(self, nIn, nHidden, nOut): super(BidirectionalLSTM, self).__init__() self.rnn = nn.LSTM(nIn, nHidden, bidirectional=True) self.embedding = nn.Linear(nHidden * 2, nOut) def forward(self, input): self.rnn.flatten_parameters() recurrent, _ = self.rnn(input) T, b, h = recurrent.size() t_rec = recurrent.view(T * b, h) output = self.embedding(t_rec) # [T * b, nOut] output = output.view(T, b, -1) return output class CRNN(nn.Module): def __init__(self, opt, leakyRelu=False): super(CRNN, self).__init__() assert opt[&#39;imgH&#39;] % 16 == 0, &#39;imgH has to be a multiple of 16&#39; ks = [3, 3, 3, 3, 3, 3, 2] ps = [1, 1, 1, 1, 1, 1, 0] ss = [1, 1, 1, 1, 1, 1, 1] nm = [64, 128, 256, 256, 512, 512, 512] cnn = nn.Sequential() def convRelu(i, batchNormalization=False): nIn = opt[&#39;nChannels&#39;] if i == 0 else nm[i - 1] nOut = nm[i] cnn.add_module(&#39;conv{0}&#39;.format(i), nn.Conv2d(nIn, nOut, ks[i], ss[i], ps[i])) if batchNormalization: cnn.add_module(&#39;batchnorm{0}&#39;.format(i), nn.BatchNorm2d(nOut)) if leakyRelu: cnn.add_module(&#39;relu{0}&#39;.format(i), nn.LeakyReLU(0.2, inplace=True)) else: cnn.add_module(&#39;relu{0}&#39;.format(i), nn.ReLU(True)) convRelu(0) cnn.add_module(&#39;pooling{0}&#39;.format(0), nn.MaxPool2d(2, 2)) # 64x16x64 convRelu(1) cnn.add_module(&#39;pooling{0}&#39;.format(1), nn.MaxPool2d(2, 2)) # 128x8x32 convRelu(2, True) convRelu(3) cnn.add_module(&#39;pooling{0}&#39;.format(2), nn.MaxPool2d((2, 2), (2, 1), (0, 1))) # 256x4x16 convRelu(4, True) convRelu(5) cnn.add_module(&#39;pooling{0}&#39;.format(3), nn.MaxPool2d((2, 2), (2, 1), (0, 1))) # 512x2x16 convRelu(6, True) # 512x1x16 self.cnn = cnn self.rnn = nn.Sequential() self.rnn = nn.Sequential( BidirectionalLSTM(opt[&#39;nHidden&#39;]*2, opt[&#39;nHidden&#39;], opt[&#39;nHidden&#39;]), BidirectionalLSTM(opt[&#39;nHidden&#39;], opt[&#39;nHidden&#39;], opt[&#39;nClasses&#39;])) def forward(self, input): # conv features conv = self.cnn(input) b, c, h, w = conv.size() assert h == 1, &quot;the height of conv must be 1&quot; conv = conv.squeeze(2) conv = conv.permute(2, 0, 1) # [w, b, c] # rnn features output = self.rnn(conv) output = output.transpose(1,0) #Tbh to bth return output . The CTC Loss . Cool, now that we have our data and model pipeline ready, it is time to define our loss function which in our case is the CTC loss function. We will be using PyTorch’s excellent CTC implementation. CTC stands for Connectionist Temporal Classification and was proposed by Alex Graves in his paper Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks. . Honestly, the above work has been a gamechanger for many sequences based tasks like speech and text recognition. For all the sequence-based tasks it is important for the input and output labels to be properly aligned. Proper alignment leads to efficient loss computation between the network predictions and expected output. In segmentation based approaches i.e. when the input word or line has been segmented into its constituent characters, there exists a direct one-to-one mapping between the segmented images of characters and the output labels. However, as you might imagine obtaining such segmentations for each character can be a very tedious and time-consuming task. Thus, CTC based transcription layers have become the de-facto choice for OCRs and speech recognition module since it allows loss computation without explicit mapping between the input and output. The CTC layer takes the output from the LSTMs and computes a score with all possible alignments of the target label. The OCR is then trained to predict a sequence which maximizes the sum of all such scores. . If you want more thorough details regarding the CTC layer I would suggest you go through the following blogs and lecture video . CMU Deep Learning Course Lecture 14 | Sequence Labelling with CTC | . class CustomCTCLoss(torch.nn.Module): # T x B x H =&gt; Softmax on dimension 2 def __init__(self, dim=2): super().__init__() self.dim = dim self.ctc_loss = torch.nn.CTCLoss(reduction=&#39;mean&#39;, zero_infinity=True) def forward(self, logits, labels, prediction_sizes, target_sizes): EPS = 1e-7 loss = self.ctc_loss(logits, labels, prediction_sizes, target_sizes) loss = self.sanitize(loss) return self.debug(loss, logits, labels, prediction_sizes, target_sizes) def sanitize(self, loss): EPS = 1e-7 if abs(loss.item() - float(&#39;inf&#39;)) &lt; EPS: return torch.zeros_like(loss) if math.isnan(loss.item()): return torch.zeros_like(loss) return loss def debug(self, loss, logits, labels, prediction_sizes, target_sizes): if math.isnan(loss.item()): print(&quot;Loss:&quot;, loss) print(&quot;logits:&quot;, logits) print(&quot;labels:&quot;, labels) print(&quot;prediction_sizes:&quot;, prediction_sizes) print(&quot;target_sizes:&quot;, target_sizes) raise Exception(&quot;NaN loss obtained. But why?&quot;) return loss . The Training Loop . The above code snippet builds a wrapper around pytorch’s CTC loss function. Basically, what it does is that it computes the loss and passes it through an additional method called debug, which checks for instances when the loss becomes Nan. . Shout out to Jerin Philip for this code. . Till now we have defined all the important components which we need to build our OCR. We have defined the data pipeline, our model as well as the loss function. Now its time to talk abot our training loop. The below code might look a bit cumbersome but it provides a nice abstraction which is quite intuitive and easy to use. The code is based on pytorch lighning’s bolier plate template with few modifications of my own. :P . I will give a basic overview of what it does. Feel free to inspect each method using python debugger. The OCRTrainer class takes in the training and validation data. It also takes in the loss function, optimizer and the number of epochs it needs to train the model. The train and validation loader method returns the data loader for the train and validation data. The run_batch method does one forward pass for a batch of image-label pairs. It returns the loss as well as the character and word accuracy. Next, we have the step function which performs the backpropagation, calculates the gradients and updates the parameters for each batch of data. Besides we also have the training_end and validation_end methods that calculate the mean loss and accuracy for all the batchs after the completion of one single epoch . The methods defined are quite simple and I hope you will get the hang of it in no time. . class OCRTrainer(object): def __init__(self, opt): super(OCRTrainer, self).__init__() self.data_train = opt[&#39;data_train&#39;] self.data_val = opt[&#39;data_val&#39;] self.model = opt[&#39;model&#39;] self.criterion = opt[&#39;criterion&#39;] self.optimizer = opt[&#39;optimizer&#39;] self.schedule = opt[&#39;schedule&#39;] self.converter = OCRLabelConverter(opt[&#39;alphabet&#39;]) self.evaluator = Eval() print(&#39;Scheduling is {}&#39;.format(self.schedule)) self.scheduler = CosineAnnealingLR(self.optimizer, T_max=opt[&#39;epochs&#39;]) self.batch_size = opt[&#39;batch_size&#39;] self.count = opt[&#39;epoch&#39;] self.epochs = opt[&#39;epochs&#39;] self.cuda = opt[&#39;cuda&#39;] self.collate_fn = opt[&#39;collate_fn&#39;] self.init_meters() def init_meters(self): self.avgTrainLoss = AverageMeter(&quot;Train loss&quot;) self.avgTrainCharAccuracy = AverageMeter(&quot;Train Character Accuracy&quot;) self.avgTrainWordAccuracy = AverageMeter(&quot;Train Word Accuracy&quot;) self.avgValLoss = AverageMeter(&quot;Validation loss&quot;) self.avgValCharAccuracy = AverageMeter(&quot;Validation Character Accuracy&quot;) self.avgValWordAccuracy = AverageMeter(&quot;Validation Word Accuracy&quot;) def forward(self, x): logits = self.model(x) return logits.transpose(1, 0) def loss_fn(self, logits, targets, pred_sizes, target_sizes): loss = self.criterion(logits, targets, pred_sizes, target_sizes) return loss def step(self): self.max_grad_norm = 0.05 clip_grad_norm_(self.model.parameters(), self.max_grad_norm) self.optimizer.step() def schedule_lr(self): if self.schedule: self.scheduler.step() def _run_batch(self, batch, report_accuracy=False, validation=False): input_, targets = batch[&#39;img&#39;], batch[&#39;label&#39;] targets, lengths = self.converter.encode(targets) logits = self.forward(input_) logits = logits.contiguous().cpu() logits = torch.nn.functional.log_softmax(logits, 2) T, B, H = logits.size() pred_sizes = torch.LongTensor([T for i in range(B)]) targets= targets.view(-1).contiguous() loss = self.loss_fn(logits, targets, pred_sizes, lengths) if report_accuracy: probs, preds = logits.max(2) preds = preds.transpose(1, 0).contiguous().view(-1) sim_preds = self.converter.decode(preds.data, pred_sizes.data, raw=False) ca = np.mean((list(map(self.evaluator.char_accuracy, list(zip(sim_preds, batch[&#39;label&#39;])))))) wa = np.mean((list(map(self.evaluator.word_accuracy, list(zip(sim_preds, batch[&#39;label&#39;])))))) return loss, ca, wa def run_epoch(self, validation=False): if not validation: loader = self.train_dataloader() pbar = tqdm(loader, desc=&#39;Epoch: [%d]/[%d] Training&#39;%(self.count, self.epochs), leave=True) self.model.train() else: loader = self.val_dataloader() pbar = tqdm(loader, desc=&#39;Validating&#39;, leave=True) self.model.eval() outputs = [] for batch_nb, batch in enumerate(pbar): if not validation: output = self.training_step(batch) else: output = self.validation_step(batch) pbar.set_postfix(output) outputs.append(output) self.schedule_lr() if not validation: result = self.train_end(outputs) else: result = self.validation_end(outputs) return result def training_step(self, batch): loss, ca, wa = self._run_batch(batch, report_accuracy=True) self.optimizer.zero_grad() loss.backward() self.step() output = OrderedDict({ &#39;loss&#39;: abs(loss.item()), &#39;train_ca&#39;: ca.item(), &#39;train_wa&#39;: wa.item() }) return output def validation_step(self, batch): loss, ca, wa = self._run_batch(batch, report_accuracy=True, validation=True) output = OrderedDict({ &#39;val_loss&#39;: abs(loss.item()), &#39;val_ca&#39;: ca.item(), &#39;val_wa&#39;: wa.item() }) return output def train_dataloader(self): # logging.info(&#39;training data loader called&#39;) loader = torch.utils.data.DataLoader(self.data_train, batch_size=self.batch_size, collate_fn=self.collate_fn, shuffle=True) return loader def val_dataloader(self): # logging.info(&#39;val data loader called&#39;) loader = torch.utils.data.DataLoader(self.data_val, batch_size=self.batch_size, collate_fn=self.collate_fn) return loader def train_end(self, outputs): for output in outputs: self.avgTrainLoss.add(output[&#39;loss&#39;]) self.avgTrainCharAccuracy.add(output[&#39;train_ca&#39;]) self.avgTrainWordAccuracy.add(output[&#39;train_wa&#39;]) train_loss_mean = abs(self.avgTrainLoss.compute()) train_ca_mean = self.avgTrainCharAccuracy.compute() train_wa_mean = self.avgTrainWordAccuracy.compute() result = {&#39;train_loss&#39;: train_loss_mean, &#39;train_ca&#39;: train_ca_mean, &#39;train_wa&#39;: train_wa_mean} # result = {&#39;progress_bar&#39;: tqdm_dict, &#39;log&#39;: tqdm_dict, &#39;val_loss&#39;: train_loss_mean} return result def validation_end(self, outputs): for output in outputs: self.avgValLoss.add(output[&#39;val_loss&#39;]) self.avgValCharAccuracy.add(output[&#39;val_ca&#39;]) self.avgValWordAccuracy.add(output[&#39;val_wa&#39;]) val_loss_mean = abs(self.avgValLoss.compute()) val_ca_mean = self.avgValCharAccuracy.compute() val_wa_mean = self.avgValWordAccuracy.compute() result = {&#39;val_loss&#39;: val_loss_mean, &#39;val_ca&#39;: val_ca_mean, &#39;val_wa&#39;: val_wa_mean} return result . Putting Everything Together . Finally, we have the Learner class. It implements a couple more methods like the save and load. It also tracks the losses and saves them in a csv file. This comes in handy if we want to analyze the behaviour of our training and validation loops. It initializes our OCRTrainer module with the necessary hyperparameters and later calls the fit method which runs the training loop. . Besides these methods, we have a bunch of helper methods like the OCRLabel_converter, Eval and Averagemeter. I am not including them in this notebook, instead, I have written them in utils.py file and I am importing them from there. In case you want to take a peek, feel free to tinker with the utils.py file. All the necessary documentation is provided in the file itself. . class Learner(object): def __init__(self, model, optimizer, savepath=None, resume=False): self.model = model self.optimizer = optimizer self.savepath = os.path.join(savepath, &#39;best.ckpt&#39;) self.cuda = torch.cuda.is_available() self.cuda_count = torch.cuda.device_count() if self.cuda: self.model = self.model.cuda() self.epoch = 0 if self.cuda_count &gt; 1: print(&quot;Let&#39;s use&quot;, torch.cuda.device_count(), &quot;GPUs!&quot;) self.model = nn.DataParallel(self.model) self.best_score = None if resume and os.path.exists(self.savepath): self.checkpoint = torch.load(self.savepath) self.epoch = self.checkpoint[&#39;epoch&#39;] self.best_score=self.checkpoint[&#39;best&#39;] self.load() else: print(&#39;checkpoint does not exist&#39;) def fit(self, opt): opt[&#39;cuda&#39;] = self.cuda opt[&#39;model&#39;] = self.model opt[&#39;optimizer&#39;] = self.optimizer logging.basicConfig(filename=&quot;%s/%s.csv&quot; %(opt[&#39;log_dir&#39;], opt[&#39;name&#39;]), level=logging.INFO) self.saver = EarlyStopping(self.savepath, patience=15, verbose=True, best_score=self.best_score) opt[&#39;epoch&#39;] = self.epoch trainer = OCRTrainer(opt) for epoch in range(opt[&#39;epoch&#39;], opt[&#39;epochs&#39;]): train_result = trainer.run_epoch() val_result = trainer.run_epoch(validation=True) trainer.count = epoch info = &#39;%d, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f&#39;%(epoch, train_result[&#39;train_loss&#39;], val_result[&#39;val_loss&#39;], train_result[&#39;train_ca&#39;], val_result[&#39;val_ca&#39;], train_result[&#39;train_wa&#39;], val_result[&#39;val_wa&#39;]) logging.info(info) self.val_loss = val_result[&#39;val_loss&#39;] print(self.val_loss) if self.savepath: self.save(epoch) if self.saver.early_stop: print(&quot;Early stopping&quot;) break def load(self): print(&#39;Loading checkpoint at {} trained for {} epochs&#39;.format(self.savepath, self.checkpoint[&#39;epoch&#39;])) self.model.load_state_dict(self.checkpoint[&#39;state_dict&#39;]) if &#39;opt_state_dict&#39; in self.checkpoint.keys(): print(&#39;Loading optimizer&#39;) self.optimizer.load_state_dict(self.checkpoint[&#39;opt_state_dict&#39;]) def save(self, epoch): self.saver(self.val_loss, epoch, self.model, self.optimizer) . Defining the hyperparameters . We have come a long way now and there is just one more hurdle to cross before we can start training our model. We begin by defining our vocabulary i.e. the alphabets which serve as the output classes for our model. We define a suitable name for this experiment which will also serve as the folder name where the checkpoints and log files will be stored. We also define the hyper-parameters like the batch size, learning rate, image height, number of channels etc. . Then we initialize our Dataset class and split the data into train and validation. We then proceed to initialize our Model and CTCLoss and finally call the learner.fit function. . Once the training is over we can find the saved model in the checkpoints/name folder. We may load the model and evaluate its performance on the test data or finetune it on some other data. . alphabet = &quot;&quot;&quot;Only thewigsofrcvdampbkuq.$A-210xT5&#39;MDL,RYHJ&quot;ISPWENj&amp;BC93VGFKz();#:!7U64Q8?+*ZX/%&quot;&quot;&quot; args = { &#39;name&#39;:&#39;exp1&#39;, &#39;path&#39;:&#39;data&#39;, &#39;imgdir&#39;: &#39;train&#39;, &#39;imgH&#39;:32, &#39;nChannels&#39;:1, &#39;nHidden&#39;:256, &#39;nClasses&#39;:len(alphabet), &#39;lr&#39;:0.001, &#39;epochs&#39;:4, &#39;batch_size&#39;:32, &#39;save_dir&#39;:&#39;checkpoints&#39;, &#39;log_dir&#39;:&#39;logs&#39;, &#39;resume&#39;:False, &#39;cuda&#39;:False, &#39;schedule&#39;:False } data = SynthDataset(args) args[&#39;collate_fn&#39;] = SynthCollator() train_split = int(0.8*len(data)) val_split = len(data) - train_split args[&#39;data_train&#39;], args[&#39;data_val&#39;] = random_split(data, (train_split, val_split)) print(&#39;Traininig Data Size:{} nVal Data Size:{}&#39;.format( len(args[&#39;data_train&#39;]), len(args[&#39;data_val&#39;]))) args[&#39;alphabet&#39;] = alphabet model = CRNN(args) args[&#39;criterion&#39;] = CustomCTCLoss() savepath = os.path.join(args[&#39;save_dir&#39;], args[&#39;name&#39;]) gmkdir(savepath) gmkdir(args[&#39;log_dir&#39;]) optimizer = torch.optim.Adam(model.parameters(), lr=args[&#39;lr&#39;]) learner = Learner(model, optimizer, savepath=savepath, resume=args[&#39;resume&#39;]) learner.fit(args) . Evaluation and testing . Once, our model is trained we can evaluate its performance on the test data. I have written a separate function get_accuracy which takes in the trained model and the test data and performs a forward pass which gives us the logits. Once we get the logits we perform an argmax operation at each time step which we treat as our predicted class. Finally, we perform a decoding operation which converts the token ids to their respective class ids. We compare the predicted string with its corresponding ground-truth which gives us the accuracy. We do it for all the images in our test data and take the mean accuracy. . We also display random 20 images from our test data with its corresponding predicted label using the Matplotlib library . import matplotlib.pyplot as plt from torchvision.utils import make_grid . device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;) def get_accuracy(args): loader = torch.utils.data.DataLoader(args[&#39;data&#39;], batch_size=args[&#39;batch_size&#39;], collate_fn=args[&#39;collate_fn&#39;]) model = args[&#39;model&#39;] model.eval() converter = OCRLabelConverter(args[&#39;alphabet&#39;]) evaluator = Eval() labels, predictions, images = [], [], [] for iteration, batch in enumerate(tqdm(loader)): input_, targets = batch[&#39;img&#39;].to(device), batch[&#39;label&#39;] images.extend(input_.squeeze().detach()) labels.extend(targets) targets, lengths = converter.encode(targets) logits = model(input_).transpose(1, 0) logits = torch.nn.functional.log_softmax(logits, 2) logits = logits.contiguous().cpu() T, B, H = logits.size() pred_sizes = torch.LongTensor([T for i in range(B)]) probs, pos = logits.max(2) pos = pos.transpose(1, 0).contiguous().view(-1) sim_preds = converter.decode(pos.data, pred_sizes.data, raw=False) predictions.extend(sim_preds) # make_grid(images[:10], nrow=2) fig=plt.figure(figsize=(8, 8)) columns = 4 rows = 5 for i in range(1, columns*rows +1): img = images[i] img = (img - img.min())/(img.max() - img.min()) img = np.array(img * 255.0, dtype=np.uint8) fig.add_subplot(rows, columns, i) plt.title(predictions[i]) plt.axis(&#39;off&#39;) plt.imshow(img) plt.show() ca = np.mean((list(map(evaluator.char_accuracy, list(zip(predictions, labels)))))) wa = np.mean((list(map(evaluator.word_accuracy_line, list(zip(predictions, labels)))))) return ca, wa . args[&#39;imgdir&#39;] = &#39;test&#39; args[&#39;data&#39;] = SynthDataset(args) resume_file = os.path.join(args[&#39;save_dir&#39;], args[&#39;name&#39;], &#39;best.ckpt&#39;) if os.path.isfile(resume_file): print(&#39;Loading model %s&#39;%resume_file) checkpoint = torch.load(resume_file) model.load_state_dict(checkpoint[&#39;state_dict&#39;]) args[&#39;model&#39;] = model ca, wa = get_accuracy(args) print(&quot;Character Accuracy: %.2f nWord Accuracy: %.2f&quot;%(ca, wa)) else: print(&quot;=&gt; no checkpoint found at &#39;{}&#39;&quot;.format(save_file)) print(&#39;Exiting&#39;) . 0%| | 0/2 [00:00&lt;?, ?it/s] Loading model checkpoints/exp1/best.ckpt 100%|██████████| 2/2 [00:00&lt;00:00, 2.25it/s] . . Character Accuracy: 98.89 Word Accuracy: 98.03 . Conclusion . In this blog we looked at how we can build an OCR from scratch using PyTorch. For this we defined the three basic module i.e. the data module, the model and a custom loss fucntion. We then tied a wrapper around the modules in the form of a OCRTrainer class which handles the forward and backward propadation as well as the accuracies. We also defined our Learner class which contains the fit method which initilizes the Trainer class and starts training OCR model and later saves it. Finally we tested our model on a heldout set and evaluated its performance in terms of Character and Word accuracy. .",
            "url": "https://deepayan137.github.io/blog/markdown/2020/08/29/building-ocr.html",
            "relUrl": "/markdown/2020/08/29/building-ocr.html",
            "date": " • Aug 29, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "A primer on semi-supervised Learning",
            "content": "Deep Learning (DL) algorithms typically rely on a huge amount of labelled data pairs. However, it is often expensive to collect such annotated datasets in terms of both cost and time. ImageNet, the largest image database in the present day consists of around 14 million images. Each image in it was hand-annotated by several annotators using a crowdsourcing platform known as Amazon Mechanical Turk. There are several other image datasets like PASCAL VOC and MS COCO which consist far fewer images compared to ImageNet (10k and 100k respectively) and it is possible to train a DL network on such dataset satisfactorily to learn a new task. However, the general trend in DL literature suggests that the performance of the models can further be improved if more and more data is added. . Transfer Learning . As mentioned above Deep Learning algorithms are essentially data-hungry methods which require tons of data to estimate its millions of parameters. This property effectively renders it useless to problems that have limited training data. However, DL models have this remarkable ability where the representations learned over large datasets can be effectively transferred to tasks which have a limited amount of training data. [2] explored applied this idea and applied it to train deep CNN models on limited labelled data. The observed that . CNN can act as a generic extractor of mid-level image representation, which can be pre-trained on one dataset (the source task) and then re-used on other target tasks. . The authors pre-trained a network on 1000 classes of ImageNet data and used to perform object detection on Pascal VOC data. Applying this method they were able to achieve a significant gain in performance compared to the existing baseline results. Besides, transfer learning has shown great promise in other computer vision tasks such as segmentation [3] and recognition [4]. . Although, transfer learning is a very useful trick for improving gains on tasks with limited training data, yet it does not take advantage of the massive amounts of unlabeled data available over the internet. Also, it suffers from the in consequence of having to annotate a portion of target data which can prove to be quite a lot if the task involves speech or text recognition. In such a case each word and utterance has to be correctly transcribed manually which can prove to be very tedious and time-consuming. . Semi-supervised Learning . These above drawbacks can be easily overcome by semi-supervised learning algorithms which are designed is such a way that they can work with both labelled and unlabeled data. Consider Google Images or Instagram. A simple query can fetch you thousands of results. However, the retrieved images are unstructured and unannotated and cannot be put to use if we are using supervised learning algorithms. Semi-supervised learning algorithms, on the other hand, make use of not only the labelled target data but also use the myriads of unlabeled data to learn better representations. This property gives an edge to the SSL algorithms over traditional finetuning approaches. There exist mainly two approaches towards implementing SSL. The first approach involves passing of the unlabeled images through different augmentations and perturbations. Since the images are constant, the model predictions should not be swayed by the perturbations and predict the same label. Forcing the model to come up with the same prediction under a different set of noise/perturbation can act as a source of regularization and together with the supervised loss term, it helps the DL model towards more stable generalization during testing and also helps the model learn more robust invariant features [5, 6]. The second approach involves inferring labels for the unlabeled data and which is then ( pseudo-labelled data) used to train the model with a supervised loss term. The second approach which is also known as pseudo-labelling falls under the category of transductive learning where both labelled and unlabeled data is used to improve the performance of a model. Labels for the unlabeled data can be inferred in two ways. 1) By constructing a graph and propagating labels from known to unknown data points and 2) By using an existing pre-trained classifier to invoke the labels unlabeled data points. . Label Propagation . Label propagation [7, 8] deals with the construction of a graph between the labelled and unlabeled data points which is later used to propagate the labels from labelled to unlabeled data using cluster assumptions. Label Propagation comprises of two steps: construction of a graph and inference. In the graph construction stage, data points of both labelled and unlabeled data form the nodes while the edges represent the similarity between the data points. Larger edge weights indicate higher similarity between the data points and vice-versa. The most common technique to create a graph is using a clustering algorithm such as kNN where the edge weights are obtained using as a Euclidean based distance function. In the inference stage, the labels from the labelled data are propagated to their nearest unlabeled data points along with a certainty score which is simply the Euclidean distance from the nearest labelled data point. . Self-training . Self-training [9, 10] was one of the earliest attempts to use unlabeled data to boost model performance. Self-training comprises of two stages: Initially, the model is trained on a limited amount of labelled data using a supervised method. In the next stage, the learned model is used to predict the labels of unlabeled data points. Finally, the model is trained on both the labelled and unlabeled data where the predictions of unlabeled data are treated as target labels. One of the major concerns of self-training is that initial trained model might predict a significant amount of unlabeled data erroneously. This might bring down the performance of a model while training rather than improving. Care should be taken to minimize the number of noisy predictions in the training set. One way to do so would be to screen the predictions effectively and include only those predictions on which the model is highly confident. Despite the screening measure, some noisy predictions still manage to creep into the training data, which hinders the learning of the ML algorithm. Most works in this domain discuss providing perturbations to the input data or model as a way to overcome confirmation bias. We will see in the next few sections of how linear perturbation is known as mixup [11] and as well as some other regularization method are used to improve the performance of a text recognition system on an unlabeled target dataset. . In the next post, we will get our hands dirty trying to implement self-training algorithm on a classic computer vision problem of text-recognition or more commonly known as OCR. . [1] ImageNet Large Scale Visual Recognition Challenge . [2] Learning and Transferring Mid-Level Image Representations using Convolutional Neural Networks . [3] Fully Convolutional Networks for Semantic Segmentation . [4] Deep Residual Learning for Image Recognition . [5] Regularization With Stochastic Transformations and Perturbations for Deep Semi-Supervised Learning] . [6] Temporal Ensembling for semi-supervised learning . [7] Label Propagation for Deep Semi-supervised Learning . [8] Learning by association â€“ a versatile semi-supervised training method for neural networks . [9] Probability of error of some adaptive pattern-recognition machines . [10] Learning to recognize patterns without a teacher . [11] mixup beyond empirical risk minimization .",
            "url": "https://deepayan137.github.io/blog/markdown/2020/08/12/Self-Training.html",
            "relUrl": "/markdown/2020/08/12/Self-Training.html",
            "date": " • Aug 12, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": ".",
          "url": "https://deepayan137.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://deepayan137.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}